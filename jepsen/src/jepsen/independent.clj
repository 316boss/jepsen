(ns jepsen.independent
  "Some tests are expensive to check--for instance, linearizability--which
  requires we verify only short histories. But if histories are short, we may
  not be able to sample often or long enough to reveal concurrency errors. This
  namespace supports splitting a test into independent components--for example
  taking a test of a single register and lifting it to a *map* of keys to
  registers."
  (:require [jepsen.util :refer [map-kv]]
            [jepsen.checker :refer [check Checker]]
            [jepsen.generator :as gen :refer [Generator]]
            [clojure.core.reducers :as r]))
(defn tuple
  "Constructs a kv tuple"
  [k v]
  (clojure.lang.MapEntry. k v))

(defn tuple?
  "Is the given value generated by an independent generator?"
  [value]
  (instance? clojure.lang.MapEntry value))

(defn sequential-generator
  "Takes a sequence of keys (k1 k2 ...), and a function (fgen k) which, when
  called with a key, yields a generator. Returns a generator which starts with
  the first key k1 and constructs a generator gen1 from (fgen k1). Returns
  elements from gen1 until it is exhausted, then moves to k2.

  The generator wraps each :value in the operations it generates. Let (:value
  (op gen1)) be v; then the generator we construct yields the kv tuple [k1 v].

  fgen must be pure and idempotent."
  [keys fgen]
  (let [state (atom {:keys keys
                     :gen  (when-let [k1 (first keys)]
                             (fgen k1))})]
    (reify Generator
      (op [this test process]
        (let [{:keys [keys gen] :as s} @state]
          (when-let [k (first keys)]
            (if-let [op (gen/op gen test process)]
              (assoc op :value (tuple k (:value op)))
              ; Generator exhausted
              (when-let [keys' (next keys)]
                (compare-and-set! state s {:keys keys'
                                           :gen  (fgen (first keys'))})
                (recur test process)))))))))

(defn history-keys
  "Takes a history and returns the set of keys in it."
  [history]
  (->> history
       (reduce (fn [ks op]
                 (let [v (:value op)]
                   (if (tuple? v)
                     (conj! ks (key v))
                     ks)))
               (transient #{}))
       persistent!))

(defn subhistory
  "Takes a history and a key k and yields the subhistory composed of all ops in
  history which do not have values with a differing key, unwrapping tuples to
  their original values."
  [k history]
  (->> history
       (keep (fn [op]
               (let [v (:value op)]
                 (cond
                   (not (tuple? v)) op
                   (= k (key v))    (assoc op :value (val v))
                   true             nil))))))

(defn checker
  "Takes a checker that operates on :values like `v`, and lifts it to a checker
  that operates on histories with values of `[k v]` tuples--like those
  generated by `sequential-generator`.

  We partition the history into (count (distinct keys)) subhistories. The
  subhistory for key k contains every element from the original history
  *except* those whose values are MapEntries with a different key. This means
  that every history sees, for example, un-keyed nemesis operations or
  informational logging.

  The checker we build is valid iff the given checker is valid for all
  subhistories. Under the :results key we store a map of keys to the results
  from the underlying checker on the subhistory for that key. :failures is the
  subset of that :results map which were not valid."
  [checker]
  (reify Checker
    (check [this test model history]
      (let [ks       (history-keys history)
            results  (->> ks
                          (map (fn [k]
                                 (let [h (subhistory k history)]
                                   [k (check checker test model h)])))
                          (into {}))
            failures (->> results
                          (reduce (fn [failures [k result]]
                                    (if (:valid? result)
                                      failures
                                      (assoc! failures k result)))
                                  (transient {}))
                          persistent!)]
        {:valid? (empty? failures)
         :results results
         :failures failures}))))
